<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat with your Projects</title>
    <style>
        @custom-variant dark (&:is(.dark *));

        :root {
            --font-size: 16px;
            --background: #ffffff;
            --foreground: oklch(0.145 0 0);
            --card: #ffffff;
            --card-foreground: oklch(0.145 0 0);
            --popover: oklch(1 0 0);
            --popover-foreground: oklch(0.145 0 0);
            --primary: #030213;
            --primary-foreground: oklch(1 0 0);
            --secondary: oklch(0.95 0.0058 264.53);
            --secondary-foreground: #030213;
            --muted: #ececf0;
            --muted-foreground: #717182;
            --accent: #e9ebef;
            --accent-foreground: #030213;
            --destructive: #d4183d;
            --destructive-foreground: #ffffff;
            --border: rgba(0, 0, 0, 0.1);
            --input: transparent;
            --input-background: #f3f3f5;
            --switch-background: #cbced4;
            --font-weight-medium: 500;
            --font-weight-normal: 400;
            --ring: oklch(0.708 0 0);
            --radius: 0.625rem;
            --sidebar: oklch(0.985 0 0);
            --sidebar-foreground: oklch(0.145 0 0);
            --sidebar-primary: #030213;
            --sidebar-primary-foreground: oklch(0.985 0 0);
            --sidebar-accent: oklch(0.97 0 0);
            --sidebar-accent-foreground: oklch(0.205 0 0);
            --sidebar-border: oklch(0.922 0 0);
            --sidebar-ring: oklch(0.708 0 0);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: var(--font-size);
        }

        body {
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            background: var(--background);
            color: var(--foreground);
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 35%;
            background: var(--sidebar);
            color: var(--sidebar-foreground);
            padding: 48px 16px 48px 16px;
            overflow-y: auto;
            border-right: 1px solid var(--sidebar-border);
            transition: transform 0.3s ease, width 0.3s ease;
            position: relative;
        }

        .sidebar.hidden {
            transform: translateX(-100%);
            width: 0;
            padding: 0;
            overflow: hidden;
        }

        .sidebar-close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 32px;
            height: 32px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #6b7280;
            transition: all 0.2s;
        }

        .sidebar-close-btn:hover {
            background: #f3f4f6;
            color: var(--foreground);
        }

        .sidebar-open-btn {
            position: fixed;
            top: 16px;
            left: 16px;
            width: 40px;
            height: 40px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: white;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #6b7280;
            transition: all 0.2s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }

        .sidebar-open-btn.visible {
            display: flex;
        }

        .sidebar-open-btn:hover {
            background: #f9fafb;
            color: var(--foreground);
        }

        .sidebar-header {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
        }

        .sidebar-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 24px;
            border-bottom: 1px solid #e5e7eb;
        }

        .sidebar-tab {
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            bottom: -1px;
        }

        .sidebar-tab:hover {
            color: var(--foreground);
        }

        .sidebar-tab.active {
            color: var(--foreground);
            border-bottom-color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .icon-btn {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--background);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--muted-foreground);
            transition: all 0.2s;
        }

        .icon-btn:hover {
            background: var(--accent);
            color: var(--foreground);
        }

        .project-label {
            font-size: 13px;
            color: var(--muted-foreground);
            margin-bottom: 6px;
            font-weight: var(--font-weight-normal);
        }

        .project-title {
            font-size: 28px;
            font-weight: 500;
            color: var(--sidebar-foreground);
            margin-bottom: 40px;
            line-height: 1.2;
        }

        .section {
            margin-bottom: 32px;
        }

        .section-title {
            font-size: 13px;
            font-weight: 500;
            color: var(--sidebar-foreground);
            margin-bottom: 10px;
            padding: 0 4px;
        }

        .two-column-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 32px;
        }

        .two-column-grid .section {
            margin-bottom: 0;
        }

        .documents-container {
            background: #f9fafb;
            border: 1px solid #f3f4f6;
            border-radius: var(--radius);
            padding: 12px;
        }

        .document-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0;
            color: #6b7280;
            font-size: 12px;
            cursor: pointer;
            transition: color 0.2s;
            margin-bottom: 4px;
            line-height: 1.7;
        }

        .document-item:last-child {
            margin-bottom: 0;
        }

        .document-item:hover {
            color: var(--foreground);
        }

        .document-icon {
            width: 12px;
            height: 12px;
            color: var(--muted-foreground);
            flex-shrink: 0;
        }

        .person-icon {
            width: 12px;
            height: 12px;
            color: var(--muted-foreground);
            flex-shrink: 0;
            margin-right: 6px;
        }

        .section-content {
            width: 100%;
        }

        .section-content-title {
            font-size: 13px;
            font-weight: 500;
            color: var(--sidebar-foreground);
            margin-bottom: 10px;
        }

        .description-box {
            background: #f9fafb;
            border: 1px solid #f3f4f6;
            border-radius: var(--radius);
            padding: 12px;
            position: relative;
        }

        .description-scroll-container {
            max-height: 300px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .description-scroll-container.has-scroll {
            padding-bottom: 20px;
        }

        .description-box::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(to bottom, rgba(249,250,251,0), rgba(249,250,251,0.95) 70%, rgba(249,250,251,1));
            pointer-events: none;
            border-radius: 0 0 var(--radius) var(--radius);
            display: none;
        }

        .description-box.has-scroll::after {
            display: block;
        }

        .description-scroll-container::-webkit-scrollbar {
            width: 6px;
        }

        .description-scroll-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .description-scroll-container::-webkit-scrollbar-thumb {
            background: #e5e7eb;
            border-radius: 3px;
        }

        .description-scroll-container::-webkit-scrollbar-thumb:hover {
            background: #d1d5db;
        }

        .description-text {
            font-size: 13px;
            line-height: 1.6;
            color: var(--muted-foreground);
        }

        .description-section {
            margin-bottom: 20px;
        }

        .description-section:last-child {
            margin-bottom: 0;
        }

        .description-section-title {
            font-weight: 500;
            font-size: 13px;
            color: var(--foreground);
            margin-bottom: 8px;
        }

        .team-container {
            background: #f9fafb;
            border: 1px solid #f3f4f6;
            border-radius: var(--radius);
            padding: 12px;
        }

        .team-list {
            color: var(--muted-foreground);
            font-size: 12px;
            line-height: 1.7;
        }

        .team-member-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0;
            color: #6b7280;
            font-size: 12px;
            margin-bottom: 4px;
            line-height: 1.7;
        }

        .team-member-item:last-child {
            margin-bottom: 0;
        }

        .team-list p:last-child {
            margin-bottom: 0;
        }

        .team-role {
            color: #9ca3af;
        }

        .see-more-text {
            display: none;
            margin-top: 8px;
            font-size: 11px;
            color: #9ca3af;
            cursor: pointer;
            position: relative;
        }

        .see-more-text:hover {
            color: var(--foreground);
        }

        .see-more-text:hover .expanded-card {
            display: block;
        }

        .documents-container.truncated .document-item:nth-child(n+6),
        .team-list.truncated .team-member-item:nth-child(n+6) {
            display: none;
        }

        .expanded-card {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .expanded-card-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 999;
        }

        .expanded-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .expanded-card-title {
            font-size: 16px;
            font-weight: 500;
            color: var(--foreground);
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--muted-foreground);
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: var(--foreground);
        }

        .expanded-card .document-item,
        .expanded-card .team-member-item {
            display: flex !important;
            margin-bottom: 8px;
        }

        .objectives-list {
            background: #f9fafb;
            border: 1px solid #f3f4f6;
            border-radius: var(--radius);
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .objective-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            font-size: 13px;
            line-height: 1.5;
            color: #6b7280;
        }

        .objective-bullet {
            width: 6px;
            height: 6px;
            background: var(--primary);
            border-radius: 50%;
            margin-top: 6px;
            flex-shrink: 0;
        }

        .objective-label {
            font-weight: 500;
            color: var(--foreground);
        }

        /* Chat Area */
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #ffffff;
            overflow: hidden;
        }

        .chat-header {
            display: none;
        }

        .chat-subtitle {
            font-size: 13px;
            color: var(--muted-foreground);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sparkle-icon {
            width: 16px;
            height: 16px;
            color: var(--muted-foreground);
        }

        .chat-title {
            font-size: 36px;
            font-weight: 500;
            color: var(--foreground);
        }

        .chat-content {
            flex: 1;
            padding: 48px 48px 0 48px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-bottom: 24px;
        }

        .message-wrapper {
            display: flex;
            gap: 16px;
        }

        .message-wrapper.user {
            justify-content: flex-end;
        }

        .message-wrapper.assistant {
            justify-content: flex-start;
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            align-self: flex-start;
        }

        .message-avatar svg {
            width: 20px;
            height: 20px;
            color: #6b7280;
        }

        .message-content-wrapper {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: 85%;
            width: 85%;
        }

        .thinking-steps {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .thinking-step {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .thinking-step-icon {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid var(--primary);
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.3s ease;
        }

        .thinking-step-icon.filled {
            background: var(--primary);
        }

        .thinking-step-icon svg {
            width: 8px;
            height: 8px;
            color: white;
            stroke-width: 3;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .thinking-step-icon.filled svg {
            opacity: 1;
        }

        .thinking-step-text {
            font-size: 14px;
            color: #6b7280;
        }

        .message-bubble {
            padding: 12px 20px;
            border-radius: 16px;
            font-size: 15px;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .message-bubble.user {
            background: #f3f4f6;
            color: var(--foreground);
            border: 1px solid #e5e7eb;
            max-width: 85%;
        }

        .message-bubble.assistant {
            color: #000000;
            margin-top: -8px;
        }

        .message-sources {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 2px;
        }

        .sources-label {
            font-size: 12px;
            color: #9ca3af;
        }

        .sources-list {
            display: flex;
            gap: 6px;
        }

        .source-badge {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 6px;
            background: #f9fafb;
            border: 1px solid #f3f4f6;
            cursor: pointer;
            transition: background 0.2s;
        }

        .source-badge:hover {
            background: #f3f4f6;
        }

        .source-badge svg {
            width: 12px;
            height: 12px;
            color: #6b7280;
        }

        .source-badge-text {
            font-size: 12px;
            color: #6b7280;
        }

        .suggestions-section {
            padding: 12px 48px 16px 48px;
            flex-shrink: 0;
            background: #ffffff;
        }

        .suggestions-label {
            font-size: 12px;
            color: var(--muted-foreground);
            margin-bottom: 8px;
            padding: 0 4px;
        }

        .suggestions-list {
            display: flex;
            flex-direction: row;
            gap: 8px;
            margin-bottom: 12px;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 4px 0;
            scrollbar-width: thin;
            scrollbar-color: #d1d5db transparent;
        }

        .suggestions-list::-webkit-scrollbar {
            height: 6px;
        }

        .suggestions-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .suggestions-list::-webkit-scrollbar-thumb {
            background-color: #d1d5db;
            border-radius: 3px;
        }

        .suggestions-list::-webkit-scrollbar-thumb:hover {
            background-color: #9ca3af;
        }

        .suggestion-btn {
            background: var(--background);
            border: 1px solid #e5e7eb;
            border-radius: 20px;
            padding: 8px 16px;
            text-align: left;
            cursor: pointer;
            font-size: 13px;
            color: #374151;
            transition: all 0.2s;
            font-family: inherit;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .suggestion-btn:hover {
            background: #f9fafb;
            border-color: #d1d5db;
        }

        .suggestion-shimmer {
            background: linear-gradient(90deg, #f3f4f6 25%, #e5e7eb 50%, #f3f4f6 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border: 1px solid #e5e7eb;
            border-radius: 20px;
            padding: 8px 16px;
            width: 150px;
            font-size: 13px;
            line-height: 1.5;
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }

        .suggestion-shimmer::before {
            content: '\00A0';
            visibility: hidden;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }
            100% {
                background-position: -200% 0;
            }
        }

        .suggestion-btn {
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(4px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .input-container {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 24px;
            padding: 16px;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }

        .message-input {
            width: 100%;
            border: none;
            outline: none;
            padding: 0 0 8px 0;
            font-size: 16px;
            font-family: inherit;
            background: transparent;
            color: #111827;
            margin-bottom: 8px;
        }

        .message-input::placeholder {
            color: #9ca3af;
        }

        .input-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 44px;
        }

        .tool-selector {
            display: inline-flex;
            align-items: center;
            background: #f3f4f6;
            border-radius: 16px;
            padding: 4px;
            position: relative;
            height: 44px;
        }

        .tool-indicator {
            position: absolute;
            top: 4px;
            bottom: 4px;
            width: 36px;
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 12px;
            transition: left 0.3s ease-out;
            height: 36px;
        }

        .tool-indicator.search {
            left: 4px;
        }

        .tool-indicator.thinking {
            left: calc(4px + 40px);
        }

        .tool-btn {
            position: relative;
            z-index: 10;
            width: 36px;
            height: 36px;
            padding: 0;
            margin: 0;
            border: none;
            background: transparent;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: color 0.2s;
        }

        .tool-btn svg {
            width: 16px;
            height: 16px;
            display: block;
            margin: auto;
        }

        .tool-btn.active {
            color: #3b82f6;
        }

        .tool-btn:not(.active) {
            color: #9ca3af;
        }

        .input-right-icons {
            display: flex;
            align-items: center;
            gap: 2px;
            height: 44px;
        }

        .input-icon-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            margin: 0;
            border: none;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s;
            color: #9ca3af;
        }

        .input-icon-btn:hover:not(:disabled) {
            background: #f3f4f6;
            color: #4b5563;
            transform: scale(1.05);
        }

        .input-icon-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .input-icon-btn svg {
            width: 16px;
            height: 16px;
            display: block;
            margin: auto;
        }

        .send-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            margin: 0;
            border: none;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s;
            color: #9ca3af;
        }

        .send-btn:hover:not(:disabled) {
            background: #f3f4f6;
            color: #4b5563;
            transform: scale(1.05);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .send-btn svg {
            width: 16px;
            height: 16px;
            display: block;
            margin: auto;
        }

        .thinking-checkbox-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #6b7280;
            cursor: pointer;
            user-select: none;
        }

        .thinking-checkbox-label input[type="checkbox"] {
            cursor: pointer;
        }

        .thinking-box {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            margin-bottom: 12px;
            overflow: hidden;
            font-size: 15px;
            width: 100%;
        }

        .thinking-box-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            cursor: pointer;
            user-select: none;
            background: #ffffff;
            gap: 12px;
        }

        .thinking-box-header:hover {
            background: #f9fafb;
        }

        .thinking-box-title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 300;
            color: #374151;
            flex: 1;
            font-size: 15px;
        }

        .thinking-box-title span {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .thinking-box-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #6b7280;
            font-size: 13px;
        }

        .thinking-box-toggle {
            font-size: 12px;
            color: #6b7280;
            transition: transform 0.2s;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .thinking-box-toggle.collapsed {
            transform: rotate(0deg);
        }

        .thinking-box-content {
            padding: 8px 12px;
            color: #6b7280;
            line-height: 1.5;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .thinking-box-content.collapsed {
            display: none;
        }

        .hidden {
            display: none;
        }


        .message-bubble.assistant strong {
            font-weight: 600;
        }

        .message-bubble.assistant em {
            font-style: italic;
        }

        .message-bubble.assistant h1,
        .message-bubble.assistant h2,
        .message-bubble.assistant h3 {
            font-weight: 600;
            margin: 8px 0 4px 0;
        }

        .message-bubble.assistant h1:first-child,
        .message-bubble.assistant h2:first-child,
        .message-bubble.assistant h3:first-child {
            margin-top: 0;
        }

        .message-bubble.assistant h1 {
            font-size: 20px;
        }

        .message-bubble.assistant h2 {
            font-size: 18px;
        }

        .message-bubble.assistant h3 {
            font-size: 16px;
        }

        /* Session cards for Conversation Log */
        .session-card {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px 14px;
            margin-bottom: 12px;
            transition: background 0.2s;
        }

        .session-card:hover {
            background: #f3f4f6;
        }

        .session-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .session-date {
            font-size: 13px;
            font-weight: 600;
            color: var(--foreground);
        }

        .session-meta {
            font-size: 12px;
            color: #9ca3af;
        }

        .session-summary {
            font-size: 13px;
            line-height: 1.5;
            color: #6b7280;
        }
    </style>
</head>
<body>
    <!-- Open Sidebar Button (shows when sidebar is hidden) -->
    <button class="sidebar-open-btn" onclick="toggleSidebar()">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="9" y1="3" x2="9" y2="21"></line>
        </svg>
    </button>

    <!-- Sidebar -->
    <div class="sidebar">
        <!-- Close Button -->
        <button class="sidebar-close-btn" onclick="toggleSidebar()">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="9" y1="3" x2="9" y2="21"></line>
            </svg>
        </button>

        <h1 class="project-label"></h1>
        <h2 class="project-title"></h2>

        <!-- Tabs -->
        <div class="sidebar-tabs">
            <button class="sidebar-tab active" onclick="switchTab(event, 'project')">Project</button>
            <button class="sidebar-tab" onclick="switchTab(event, 'memory')">User Memory</button>
            <button class="sidebar-tab" onclick="switchTab(event, 'conversation')">Conversation Log</button>
        </div>

        <!-- Project Tab Content -->
        <div id="project-tab" class="tab-content active">
        <div class="section">
            <div class="section-content">
                <div class="section-content-title">Project Overview</div>
                <div class="description-box">
                    <div class="description-scroll-container">
                        <div class="description-text" id="descriptionText"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-content">
                <div class="section-content-title">Key Objectives</div>
                <div class="objectives-list">
                </div>
            </div>
        </div>

        <div class="two-column-grid">
            <div class="section">
                <div class="section-title">Documents</div>
                <div class="documents-container truncated">
                </div>
                <div class="see-more-text" id="seeMoreDocs">
                    See more
                </div>
            </div>

            <div class="section">
                <div class="section-content">
                    <div class="section-content-title">Team Members</div>
                    <div class="team-container">
                        <div class="team-list truncated">
                        </div>
                    </div>
                    <div class="see-more-text" id="seeMoreTeam">
                        See more
                    </div>
                </div>
            </div>
        </div>
        </div>

        <!-- User Memory Tab Content -->
        <div id="memory-tab" class="tab-content">
            <div class="section">
                <div class="section-content">
                    <div class="section-content-title">User Profile</div>
                    <div class="description-box">
                        <div class="description-scroll-container">
                            <div class="description-text" id="userProfileText"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-content">
                    <div class="section-content-title">Company Overview</div>
                    <div class="description-box">
                        <div class="description-scroll-container">
                            <div class="description-text" id="companyOverviewText"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Conversation Log Tab Content -->
        <div id="conversation-tab" class="tab-content">
            <div class="section">
                <div class="section-content">
                    <div class="section-content-title">Conversation History</div>
                    <div class="description-box">
                        <div class="description-scroll-container">
                            <div class="description-text" id="conversationLogText">
                                <p style="color: #9ca3af; font-size: 13px;">No conversations yet. Start chatting to see your conversation history here.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Chat Area -->
    <div class="chat-area">
        <div class="chat-header">
            <h1 class="chat-subtitle">
                <svg class="sparkle-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path d="M12 2L15 8.5L22 12L15 15.5L12 22L9 15.5L2 12L9 8.5L12 2Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span>Chat with your Project</span>
            </h1>
            <h2 class="chat-title">Ask me anything</h2>
        </div>

        <div class="chat-content" id="chatContent">
            <!-- Initial assistant message -->
            <div class="message-wrapper assistant">
                <div class="message-avatar">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M12 2L15 8.5L22 12L15 15.5L12 22L9 15.5L2 12L9 8.5L12 2Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
                <div class="message-content-wrapper">
                    <div class="message-bubble assistant">Hello! I'm here to help you with the Apps Pod: Espresso Milestone. Ask me anything about the project!</div>
                </div>
            </div>
        </div>

        <div class="suggestions-section">
            <div id="suggestionsContainer">
                <div class="suggestions-label">Suggested questions</div>
                <div class="suggestions-list">
                    <button class="suggestion-btn" onclick="handleSuggestionClick(this)">What should I prepare for the next sprint planning?</button>
                    <button class="suggestion-btn" onclick="handleSuggestionClick(this)">What are the biggest risks for our Espresso milestone?</button>
                    <button class="suggestion-btn" onclick="handleSuggestionClick(this)">How should we evaluate if our proactive suggestions are helpful?</button>
                </div>
            </div>

            <div class="input-container">
                <input
                    type="text"
                    class="message-input"
                    id="messageInput"
                    placeholder=""
                    onkeypress="handleKeyPress(event)"
                />

                <div class="input-controls">
                    <div class="tool-selector">
                        <div class="tool-indicator search" id="toolIndicator"></div>

                        <button class="tool-btn active" id="searchBtn" onclick="selectTool('search')" title="Normal">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"></circle>
                                <path d="m21 21-4.35-4.35"></path>
                            </svg>
                        </button>
                        <button class="tool-btn" id="thinkingBtn" onclick="selectTool('thinking')" title="Extended thinking">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"></path>
                            </svg>
                        </button>
                    </div>

                    <div class="input-right-icons">
                        <button class="input-icon-btn" title="Link" disabled>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                            </svg>
                        </button>
                        <button class="input-icon-btn" title="Attach" disabled>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="m21.44 11.05-9.19 9.19a6 6 0 0 1-8.49-8.49l8.57-8.57A4 4 0 1 1 18 8.84l-8.59 8.57a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                            </svg>
                        </button>
                        <button class="input-icon-btn" title="Voice" disabled>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                                <path d="M19 10v2a7 7 0 0 1-14 0v-2M12 19v3"></path>
                            </svg>
                        </button>
                        <button class="send-btn" id="sendBtn" onclick="sendMessage()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 19V5M5 12l7-7 7 7"></path>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>

        let hasUserSentMessage = false;
        let conversationHistory = [];
        let projectContext = null;
        let extendedThinkingEnabled = false;

        // ==============================================================================
        // MEMORY TOOL IMPLEMENTATION
        // Claude's Memory Tool - Client-side file storage backend
        // ==============================================================================

        const MEMORY_STORAGE_KEY = 'claude_memories';

        // Initialize memory storage
        function initMemoryStorage() {
            if (!localStorage.getItem(MEMORY_STORAGE_KEY)) {
                localStorage.setItem(MEMORY_STORAGE_KEY, JSON.stringify({}));
            }
        }

        // Load all memory files
        function loadMemories() {
            try {
                const stored = localStorage.getItem(MEMORY_STORAGE_KEY);
                return stored ? JSON.parse(stored) : {};
            } catch (error) {
                console.error('Error loading memories:', error);
                return {};
            }
        }

        // Save memory files
        function saveMemories(memories) {
            try {
                localStorage.setItem(MEMORY_STORAGE_KEY, JSON.stringify(memories));
            } catch (error) {
                console.error('Error saving memories:', error);
                if (error.name === 'QuotaExceededError') {
                    throw new Error('Storage quota exceeded');
                }
            }
        }

        // Validate path security - prevent directory traversal
        function validateMemoryPath(path) {
            if (!path.startsWith('/memories/')) {
                throw new Error('Invalid path: must be within /memories directory');
            }
            if (path.includes('../') || path.includes('..\\') || path.includes('%2e%2e')) {
                throw new Error('Invalid path: directory traversal not allowed');
            }
            return path;
        }

        // Handle memory tool operations
        async function handleMemoryOperation(operation, input) {
            try {
                initMemoryStorage();
                const memories = loadMemories();

                switch (operation) {
                    case 'view': {
                        const path = validateMemoryPath(input.path);

                        // If path is /memories, list all files
                        if (path === '/memories' || path === '/memories/') {
                            const files = Object.keys(memories);
                            if (files.length === 0) {
                                return { content: 'Directory is empty\n' };
                            }
                            return { content: files.map(f => f.replace('/memories/', '')).join('\n') + '\n' };
                        }

                        // View specific file
                        const content = memories[path];
                        if (content === undefined) {
                            throw new Error(`File not found: ${path}`);
                        }

                        // Handle line range if specified
                        if (input.start_line !== undefined || input.end_line !== undefined) {
                            const lines = content.split('\n');
                            const start = (input.start_line || 1) - 1;
                            const end = input.end_line || lines.length;
                            return { content: lines.slice(start, end).join('\n') + '\n' };
                        }

                        return { content: content };
                    }

                    case 'create': {
                        const path = validateMemoryPath(input.path);
                        memories[path] = input.content;
                        saveMemories(memories);
                        return { success: true, message: `Created file: ${path}` };
                    }

                    case 'str_replace': {
                        const path = validateMemoryPath(input.path);
                        if (memories[path] === undefined) {
                            throw new Error(`File not found: ${path}`);
                        }

                        const oldContent = memories[path];
                        if (!oldContent.includes(input.old_str)) {
                            throw new Error('old_str not found in file');
                        }

                        memories[path] = oldContent.replace(input.old_str, input.new_str);
                        saveMemories(memories);
                        return { success: true, message: `Updated file: ${path}` };
                    }

                    case 'insert': {
                        const path = validateMemoryPath(input.path);
                        if (memories[path] === undefined) {
                            throw new Error(`File not found: ${path}`);
                        }

                        const lines = memories[path].split('\n');
                        const insertAt = input.insert_line - 1;
                        lines.splice(insertAt, 0, input.content);
                        memories[path] = lines.join('\n');
                        saveMemories(memories);
                        return { success: true, message: `Inserted content at line ${input.insert_line}` };
                    }

                    case 'delete': {
                        const path = validateMemoryPath(input.path);
                        if (memories[path] === undefined) {
                            throw new Error(`File not found: ${path}`);
                        }

                        delete memories[path];
                        saveMemories(memories);
                        return { success: true, message: `Deleted file: ${path}` };
                    }

                    case 'rename': {
                        const oldPath = validateMemoryPath(input.old_path);
                        const newPath = validateMemoryPath(input.new_path);

                        if (memories[oldPath] === undefined) {
                            throw new Error(`File not found: ${oldPath}`);
                        }

                        memories[newPath] = memories[oldPath];
                        delete memories[oldPath];
                        saveMemories(memories);
                        return { success: true, message: `Renamed ${oldPath} to ${newPath}` };
                    }

                    default:
                        throw new Error(`Unknown memory operation: ${operation}`);
                }
            } catch (error) {
                console.error('Memory operation error:', error);
                return { error: error.message };
            }
        }


        // Load project context - THIS FILE controls both the sidebar AND AI context
        fetch('/project-context.json')
            .then(response => response.json())
            .then(data => {
                projectContext = data;
                console.log('Project context loaded:', projectContext.projectTitle);
                populateSidebar(projectContext);
                // Don't generate suggestions on initial load - use hardcoded ones
            })
            .catch(error => console.error('Error loading project context:', error));

        let expandedCardTimeout;

        function showExpandedCard(type) {
            clearTimeout(expandedCardTimeout);

            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'expanded-card-overlay';
            overlay.onclick = closeExpandedCard;

            // Create card
            const card = document.createElement('div');
            card.className = 'expanded-card';
            card.id = 'expandedCard';
            card.style.display = 'block';

            // Create header
            const header = document.createElement('div');
            header.className = 'expanded-card-header';

            const title = document.createElement('div');
            title.className = 'expanded-card-title';
            if (type === 'documents') {
                title.textContent = 'All Documents';
            } else if (type === 'team') {
                title.textContent = 'All Team Members';
            } else if (type === 'description') {
                title.textContent = 'Full Description';
            }

            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-btn';
            closeBtn.onclick = closeExpandedCard;
            closeBtn.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor">
                    <path d="M5 5L15 15M5 15L15 5" stroke-width="2" stroke-linecap="round"/>
                </svg>
            `;

            header.appendChild(title);
            header.appendChild(closeBtn);
            card.appendChild(header);

            // Add content
            if (type === 'documents') {
                const docsContainer = document.querySelector('.documents-container');
                const clone = docsContainer.cloneNode(true);
                clone.classList.remove('truncated');
                card.appendChild(clone);
            } else if (type === 'team') {
                const teamList = document.querySelector('.team-list');
                const clone = teamList.cloneNode(true);
                clone.classList.remove('truncated');
                card.appendChild(clone);
            } else if (type === 'description') {
                const descText = document.getElementById('descriptionText');
                const clone = descText.cloneNode(true);
                clone.classList.remove('truncated');
                card.appendChild(clone);
            }

            // Add to DOM
            document.body.appendChild(overlay);
            document.body.appendChild(card);
        }

        function closeExpandedCard() {
            const overlay = document.querySelector('.expanded-card-overlay');
            const card = document.getElementById('expandedCard');
            if (overlay) overlay.remove();
            if (card) card.remove();
        }

        function checkScrollableContent() {
            // Find all description boxes and check if their scroll containers need scrolling
            const scrollContainers = document.querySelectorAll('.description-scroll-container');
            scrollContainers.forEach(container => {
                if (container.scrollHeight > container.clientHeight) {
                    // Content is scrollable, add class to container and parent box
                    container.classList.add('has-scroll');
                    const parentBox = container.closest('.description-box');
                    if (parentBox) {
                        parentBox.classList.add('has-scroll');
                    }
                } else {
                    // Content is not scrollable, remove classes
                    container.classList.remove('has-scroll');
                    const parentBox = container.closest('.description-box');
                    if (parentBox) {
                        parentBox.classList.remove('has-scroll');
                    }
                }
            });
        }

        function setupSeeMore() {
            // Setup documents see more
            const docsContainer = document.querySelector('.documents-container');
            const docItems = docsContainer ? docsContainer.querySelectorAll('.document-item') : [];
            const seeMoreDocs = document.getElementById('seeMoreDocs');

            if (docItems.length > 5 && seeMoreDocs) {
                seeMoreDocs.style.display = 'block';
                seeMoreDocs.addEventListener('click', () => showExpandedCard('documents'));
            }

            // Setup team see more
            const teamList = document.querySelector('.team-list');
            const teamItems = teamList ? teamList.querySelectorAll('.team-member-item') : [];
            const seeMoreTeam = document.getElementById('seeMoreTeam');

            if (teamItems.length > 5 && seeMoreTeam) {
                seeMoreTeam.style.display = 'block';
                seeMoreTeam.addEventListener('click', () => showExpandedCard('team'));
            }
        }

        function populateSidebar(context) {
            // Update project title
            document.querySelector('.project-title').textContent = context.projectTitle;
            document.querySelector('.project-label').textContent = context.projectLabel;

            // Update documents
            const docsContainer = document.querySelector('.documents-container');
            if (context.documents && context.documents.length > 0) {
                docsContainer.innerHTML = context.documents.map(doc => `
                    <div class="document-item">
                        <svg class="document-icon" viewBox="0 0 16 16" fill="none">
                            <path d="M3 2h7l3 3v9H3V2z" stroke="currentColor" stroke-width="1.5"/>
                        </svg>
                        <span>${doc.name}</span>
                    </div>
                `).join('');
            }

            // Update team members (inside two-column-grid)
            const teamList = document.querySelector('.two-column-grid .team-list');
            if (teamList && context.teamMembers && context.teamMembers.length > 0) {
                teamList.innerHTML = context.teamMembers.map(member => `
                    <div class="team-member-item">
                        <svg class="person-icon" viewBox="0 0 16 16" fill="none">
                            <circle cx="8" cy="5" r="3" stroke="currentColor" stroke-width="1.5"/>
                            <path d="M3 14c0-2.5 2-4 5-4s5 1.5 5 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                        </svg>
                        <span>${member.name} <span class="team-role"> ${member.role}</span></span>
                    </div>
                `).join('');
            }

            // Update description
            const descText = document.querySelector('.description-text');
            if (descText && context.description) {
                const sections = [];
                if (context.description.overview) {
                    sections.push(`<div class="description-section"><div>${context.description.overview}</div></div>`);
                }
                if (context.description.meetingsWorkstream) {
                    sections.push(`<div class="description-section"><div class="description-section-title">Meetings Workstream</div><div>${context.description.meetingsWorkstream}</div></div>`);
                }
                if (context.description.proactiveSuggestionsWorkstream) {
                    sections.push(`<div class="description-section"><div class="description-section-title">Proactive Suggestions Workstream</div><div>${context.description.proactiveSuggestionsWorkstream}</div></div>`);
                }
                descText.innerHTML = sections.join('');
            }

            // Update key objectives
            const objectivesList = document.querySelector('.objectives-list');
            if (objectivesList && context.keyObjectives && context.keyObjectives.length > 0) {
                objectivesList.innerHTML = context.keyObjectives.map(obj => {
                    // Split on first colon to separate label from description
                    const colonIndex = obj.indexOf(':');
                    if (colonIndex !== -1) {
                        const label = obj.substring(0, colonIndex);
                        const description = obj.substring(colonIndex + 1).trim();
                        return `
                            <div class="objective-item">
                                <div class="objective-bullet"></div>
                                <div>
                                    <span class="objective-label">${label}:</span>
                                    <span> ${description}</span>
                                </div>
                            </div>
                        `;
                    } else {
                        return `
                            <div class="objective-item">
                                <div class="objective-bullet"></div>
                                <div>${obj}</div>
                            </div>
                        `;
                    }
                }).join('');
            }

            // Setup see more functionality after content is loaded
            setupSeeMore();

            // Populate User Memory tab
            if (context.userMemory) {
                // User Profile
                const userProfileText = document.getElementById('userProfileText');
                if (userProfileText && context.userMemory.userProfile) {
                    userProfileText.innerHTML = `<div class="description-section"><div>${context.userMemory.userProfile}</div></div>`;
                }

                // Company Overview
                const companyOverviewText = document.getElementById('companyOverviewText');
                if (companyOverviewText && context.userMemory.companyOverview) {
                    companyOverviewText.innerHTML = `<div class="description-section"><div>${context.userMemory.companyOverview}</div></div>`;
                }
            }

            // Check for scrollable content globally after all content is loaded
            setTimeout(checkScrollableContent, 100);
        }

        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const openBtn = document.querySelector('.sidebar-open-btn');

            sidebar.classList.toggle('hidden');
            openBtn.classList.toggle('visible');
        }

        function updateConversationLogUI() {
            const conversationLogText = document.getElementById('conversationLogText');
            if (!conversationLogText) return;

            // Load memory files from storage
            const memories = loadMemories();
            const sessionFiles = Object.keys(memories).filter(path => path.startsWith('/memories/session_'));

            if (sessionFiles.length === 0) {
                conversationLogText.innerHTML = '<p style="color: #9ca3af; font-size: 13px;">No conversation memory yet. As you chat, Claude will automatically save summaries here.</p>';
                return;
            }

            // Sort by filename (which contains date) - newest first
            sessionFiles.sort().reverse();

            // Build session cards HTML
            const sessionsHTML = sessionFiles.map(filePath => {
                const filename = filePath.replace('/memories/session_', '').replace('.txt', '');
                const content = memories[filePath];
                const lines = content.split('\n').filter(line => line.trim());
                const exchangeCount = lines.length;

                // Parse date from filename (format: YYYY-MM-DD)
                const dateStr = filename;
                let displayDate = dateStr;
                try {
                    const date = new Date(dateStr);
                    displayDate = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                } catch (e) {
                    // Keep original if parsing fails
                }

                // Show first 2 summaries as preview
                const preview = lines.slice(0, 2).join(' | ');
                const previewText = preview.length > 150 ? preview.substring(0, 150) + '...' : preview;

                return `
                    <div class="session-card">
                        <div class="session-header">
                            <div class="session-date">${displayDate}</div>
                            <div class="session-meta">${exchangeCount} exchange${exchangeCount !== 1 ? 's' : ''}</div>
                        </div>
                        <div class="session-summary">${previewText || 'Session in progress...'}</div>
                    </div>
                `;
            }).join('');

            conversationLogText.innerHTML = sessionsHTML;
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function handleSuggestionClick(button) {
            const question = button.textContent;
            document.getElementById('messageInput').value = question;
            sendMessage();
        }

        let selectedTool = 'search';

        function selectTool(tool) {
            selectedTool = tool;
            const indicator = document.getElementById('toolIndicator');
            const searchBtn = document.getElementById('searchBtn');
            const thinkingBtn = document.getElementById('thinkingBtn');

            // Update indicator position
            indicator.className = 'tool-indicator ' + tool;

            // Update button active states
            searchBtn.classList.toggle('active', tool === 'search');
            thinkingBtn.classList.toggle('active', tool === 'thinking');

            // Update extended thinking setting
            extendedThinkingEnabled = (tool === 'thinking');
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            if (!message) return;

            hasUserSentMessage = true;

            // Add user message to conversation
            conversationHistory.push({
                role: 'user',
                content: message
            });

            // Add user message to UI
            addUserMessage(message);
            input.value = '';

            // Disable input while processing
            input.disabled = true;
            document.getElementById('sendBtn').disabled = true;

            // Get real response from API
            await showThinkingStepsAndCallAPI(message);

            // Generate new suggestions after response
            await updateSuggestions();

            // Re-enable input
            input.disabled = false;
            document.getElementById('sendBtn').disabled = false;
            input.focus();
        }

        function addUserMessage(text) {
            const chatContent = document.getElementById('chatContent');
            const messageHtml = `
                <div class="message-wrapper user">
                    <div class="message-bubble user">${escapeHtml(text)}</div>
                </div>
            `;
            chatContent.insertAdjacentHTML('beforeend', messageHtml);
            scrollToBottom();
        }

        async function showThinkingStepsAndCallAPI(userInput) {
            const chatContent = document.getElementById('chatContent');

            // Create message wrapper for the assistant response
            const uniqueWrapperId = 'thinking-wrapper-' + Date.now();
            const thinkingWrapper = document.createElement('div');
            thinkingWrapper.className = 'message-wrapper assistant';
            thinkingWrapper.id = uniqueWrapperId;
            thinkingWrapper.innerHTML = `
                <div class="message-avatar">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M12 2L15 8.5L22 12L15 15.5L12 22L9 15.5L2 12L9 8.5L12 2Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
                <div class="message-content-wrapper"></div>
            `;
            chatContent.appendChild(thinkingWrapper);

            // Call API with streaming
            try {
                console.log('Calling API with conversation history:', conversationHistory.length, 'messages');
                await callAnthropicAPIStreaming(thinkingWrapper);
                console.log('API call completed successfully');
            } catch (error) {
                console.error('API Error caught in showThinkingStepsAndCallAPI:', error);
                console.error('Error stack:', error.stack);
                thinkingWrapper.remove();
                addAssistantMessageError('Sorry, I encountered an error. Please try again.');
            }
        }

        function addAssistantMessageError(text) {
            const chatContent = document.getElementById('chatContent');

            const messageHtml = `
                <div class="message-wrapper assistant">
                    <div class="message-avatar">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M12 2L15 8.5L22 12L15 15.5L12 22L9 15.5L2 12L9 8.5L12 2Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </div>
                    <div class="message-content-wrapper">
                        <div class="message-bubble assistant">${escapeHtml(text)}</div>
                    </div>
                </div>
            `;
            chatContent.insertAdjacentHTML('beforeend', messageHtml);
            scrollToBottom();
        }

        async function callAnthropicAPIStreaming(thinkingWrapper) {
            console.log('callAnthropicAPIStreaming started');

            // Prepare API request with prompt caching
            const requestBody = {
                model: 'claude-sonnet-4-5-20250929',
                max_tokens: 4096,
                messages: conversationHistory,
                tools: [
                    {
                        type: "web_search_20250305",
                        name: "web_search",
                        max_uses: 5
                    },
                    {
                        type: "memory_20250627",
                        name: "memory"
                    }
                ]
            };

            console.log('Request body prepared, messages count:', conversationHistory.length);

            // Add extended thinking if enabled
            if (extendedThinkingEnabled) {
                console.log('Extended thinking is ENABLED');
                requestBody.thinking = {
                    type: "enabled",
                    budget_tokens: 10000
                };
            } else {
                console.log('Extended thinking is DISABLED');
            }

            // Build system message
            let systemText = '';

            // Add project context if available
            if (projectContext && projectContext.contextForAI) {
                systemText = projectContext.contextForAI + '\n\n';
            }

            systemText += 'You are Dia, an AI assistant created by Anthropic. You should respond in a conversational, helpful manner using plain text only, as the interface cannot render markdown.';

            // Add memory tool instructions
            systemText += '\n\n## MEMORY MANAGEMENT\n\n';
            systemText += 'You have access to a memory tool that persists information across conversations. You can use it to:\n';
            systemText += '- Check /memories directory at conversation start to recall previous context\n';
            systemText += '- Optionally store important information from conversations for future reference\n';
            systemText += '- Keep session logs in /memories/session_' + new Date().toISOString().split('T')[0] + '.txt if needed\n\n';
            systemText += 'IMPORTANT: Always provide a complete text response to the user FIRST. Memory operations are optional and secondary to helping the user.';

            requestBody.system = [
                {
                    type: 'text',
                    text: systemText + '\n\n## Response Style Guidelines\n\n### General Approach\n- Write in natural paragraphs and prose as your default\n- NEVER use markdown formatting (no **, ##, ###, `, etc.) since it won\'t render\n- Keep responses proportional to the question - simple questions get concise answers, complex questions get thorough exploration\n- Use plain text only - the system cannot display formatted text\n\n### Formatting Rules\n- Never use asterisks for bold or italics - they will display as literal asterisks\n- Never use backticks for code - just write code or technical terms plainly\n- Never use headers with # symbols - they will display as literal # characters\n- Avoid lists in general - write in flowing paragraphs instead\n- Simple dash lists (using "-") are acceptable ONLY when listing short, distinct items where prose would be awkward (like a shopping list, quick options, or brief distinct points)\n- When you do use dash lists, keep each item brief - usually just a few words or one short sentence\n- For explanations, advice, or detailed content, always use prose paragraphs instead of lists\n\n### Tone and Content\n- Be conversational but not overly casual\n- Get straight to the point without unnecessary preambles like "I\'m here to help you with..."\n- Organize thoughts through clear prose rather than visual formatting\n- For technical or work-related queries, maintain professional tone while staying accessible\n\n### When Dash Lists Are Appropriate\nUse simple dash lists only for:\n- Quick enumeration of options or choices\n- Brief, distinct items that don\'t need explanation\n- When the user specifically asks for a list\n- Cases where prose would be genuinely awkward (like listing file names, short menu options, etc.)\n\nNever use lists for:\n- Explanations or advice\n- Multi-sentence points\n- Step-by-step instructions (write these in prose)\n- Organizing different topics or sections\n\n### Example Transformation\nInstead of: "For your next sprint planning, you should prepare: \n- Review Current Sprint Status: Walk through your Linear board...\n- Align on Milestone Progress: Since you\'re in the Espresso milestone..."\n\nWrite: "For your next sprint planning, you\'ll want to walk through your Linear board to understand what\'s shipping and what\'s slipping. This gives you context about blockers and helps avoid overcommitting. Since you\'re in the Espresso milestone, it\'s worth assessing where both workstreams stand against your six-week goals..."\n\nRemember: Write as if you\'re explaining something to a colleague in a plain text email or chat message. Default to prose, and only use dash lists when they genuinely make the information clearer and more scannable for very brief items.\n\n### WEB SEARCH TOOL\nYou have access to a web_search tool. Use it proactively and liberally for:\n- Current events, news, or recent information\n- Real-time data (stock prices, weather, sports scores, etc.)\n- Industry best practices and how other companies approach problems\n- Research topics where external examples would enrich your answer\n- Recent product releases, API documentation, or technology updates\n- Questions about team organization, processes, or methodologies at other companies\n- Any topic where additional research, examples, or data points would provide more comprehensive answers\n- Verifying or supplementing information even if you have some knowledge about it\n\nBe proactive: Even if you know something about a topic, use web search when external research would make your answer more helpful, current, or well-rounded. The user values thorough research over quick responses.\n\nDo NOT use web search for:\n- Questions specifically about the provided project context\n- Simple definitions or explanations you can confidently provide',
                    cache_control: { type: 'ephemeral' }
                }
            ];

            // Call API endpoint with streaming
            console.log('Fetching from /api/chat...');
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            console.log('Fetch completed, response status:', response.status, response.ok);

            if (!response.ok) {
                const errorText = await response.text();
                console.error('API error response:', errorText);
                throw new Error(`API error: ${response.status} - ${errorText}`);
            }

            console.log('Response OK, starting to read stream...');

            // Add message bubble to the existing thinking wrapper
            const uniqueId = 'streaming-' + Date.now();
            const contentWrapper = thinkingWrapper.querySelector('.message-content-wrapper');
            contentWrapper.insertAdjacentHTML('beforeend', `
                <div class="message-bubble assistant" id="${uniqueId}"></div>
            `);

            const streamingTextElement = document.getElementById(uniqueId);

            // Read the streaming response with smoother updates
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let fullText = '';
            let displayText = '';
            let pendingUpdate = false;
            let thinkingText = '';
            let thinkingDisplayText = '';
            let thinkingElement = null;
            let thinkingPendingUpdate = false;
            let thinkingBoxCreated = false;
            let isThinkingBlock = false;
            let currentToolUseId = null;
            let toolInputJson = {};
            let pendingMemoryTools = [];  // Track memory tool uses
            let assistantContent = [];  // Track full assistant message content blocks
            let stopReason = null;  // Track why the message stopped

            // Create a container for thinking/tool blocks that appears before the text
            const blocksContainerId = 'blocks-' + Date.now();
            streamingTextElement.insertAdjacentHTML('beforebegin', `<div id="${blocksContainerId}" style="width: 100%; display: flex; flex-direction: column;"></div>`);
            const blocksContainer = document.getElementById(blocksContainerId);

            // Smooth display update using requestAnimationFrame
            const updateDisplay = () => {
                if (displayText !== fullText) {
                    // Calculate how much to add (word by word for smoother effect)
                    const remaining = fullText.substring(displayText.length);
                    const nextChunk = remaining.substring(0, Math.max(1, Math.ceil(remaining.length * 0.3)));
                    displayText += nextChunk;
                    streamingTextElement.textContent = displayText;
                    scrollToBottom();

                    if (displayText !== fullText) {
                        requestAnimationFrame(updateDisplay);
                    } else {
                        pendingUpdate = false;
                    }
                } else {
                    pendingUpdate = false;
                }
            };

            const updateThinkingDisplay = () => {
                if (thinkingElement && thinkingDisplayText !== thinkingText) {
                    const remaining = thinkingText.substring(thinkingDisplayText.length);
                    const nextChunk = remaining.substring(0, Math.max(1, Math.ceil(remaining.length * 0.3)));
                    thinkingDisplayText += nextChunk;
                    thinkingElement.textContent = thinkingDisplayText;
                    scrollToBottom();

                    if (thinkingDisplayText !== thinkingText) {
                        requestAnimationFrame(updateThinkingDisplay);
                    } else {
                        thinkingPendingUpdate = false;
                    }
                } else {
                    thinkingPendingUpdate = false;
                }
            };

            while (true) {
                const { done, value } = await reader.read();

                if (done) {
                    console.log('Stream reader done');
                    break;
                }

                const chunk = decoder.decode(value, { stream: true });
                console.log('Received chunk, length:', chunk.length);
                buffer += chunk;
                const lines = buffer.split('\n');

                // Keep the last incomplete line in the buffer
                buffer = lines.pop() || '';

                console.log('Processing', lines.length, 'lines from buffer');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);

                        if (data === '[DONE]') {
                            console.log('Received [DONE] marker');
                            continue;
                        }

                        try {
                            const event = JSON.parse(data);
                            console.log('Parsed event type:', event.type);
                            console.log('Full event:', event);

                            // Check for error in event
                            if (event.error) {
                                console.error('API returned error in stream:', event.error);
                                throw new Error(`API Error: ${JSON.stringify(event.error)}`);
                            }

                            // Handle content_block_start to detect thinking vs text blocks
                            if (event.type === 'content_block_start') {
                                console.log('content_block_start:', event.content_block?.type, event);
                                if (event.content_block?.type === 'thinking') {
                                    isThinkingBlock = true;
                                    console.log('Started thinking block');
                                } else if (event.content_block?.type === 'text') {
                                    isThinkingBlock = false;
                                    console.log('Started text block');
                                } else if (event.content_block?.type === 'tool_use') {
                                    // Client-side tool use (memory tool)
                                    console.log('Client tool use started:', event.content_block.name, 'ID:', event.content_block.id);
                                    currentToolUseId = event.content_block.id;

                                    // Track memory tool uses for later execution
                                    if (event.content_block.name === 'memory') {
                                        const toolUse = {
                                            id: event.content_block.id,
                                            type: 'tool_use',
                                            name: 'memory',
                                            input: {}
                                        };
                                        pendingMemoryTools.push(toolUse);
                                        toolInputJson[event.index] = '';

                                        // Show UI indicator
                                        const toolBoxHtml = `
                                            <div class="thinking-box" id="memory-${toolUse.id}">
                                                <div class="thinking-box-header" onclick="toggleThinkingBox(event)">
                                                    <div class="thinking-box-title">
                                                        <span> Writing to memory...</span>
                                                    </div>
                                                    <div class="thinking-box-meta">
                                                        <span class="thinking-box-toggle"></span>
                                                    </div>
                                                </div>
                                                <div class="thinking-box-content collapsed" id="memory-${toolUse.id}-content"></div>
                                            </div>
                                        `;
                                        blocksContainer.insertAdjacentHTML('beforeend', toolBoxHtml);
                                    }
                                } else if (event.content_block?.type === 'server_tool_use') {
                                    console.log('Server tool use started:', event.content_block.name, 'ID:', event.content_block.id);
                                    console.log('Full content_block:', JSON.stringify(event.content_block, null, 2));
                                    currentToolUseId = event.content_block.id;

                                    // Create a box for the web search tool
                                    if (event.content_block.name === 'web_search') {
                                        const toolBoxId = 'tool-' + currentToolUseId;
                                        const searchQuery = event.content_block.input?.query || 'Searching...';
                                        console.log('Search query extracted:', searchQuery);
                                        const toolBoxHtml = `
                                            <div class="thinking-box" id="${toolBoxId}">
                                                <div class="thinking-box-header" onclick="toggleThinkingBox(event)">
                                                    <div class="thinking-box-title">
                                                        <span> ${searchQuery}</span>
                                                    </div>
                                                    <div class="thinking-box-meta">
                                                        <span id="${toolBoxId}-count">Searching...</span>
                                                        <span class="thinking-box-toggle"></span>
                                                    </div>
                                                </div>
                                                <div class="thinking-box-content collapsed" id="${toolBoxId}-content"></div>
                                            </div>
                                        `;
                                        blocksContainer.insertAdjacentHTML('beforeend', toolBoxHtml);
                                    }
                                } else if (event.content_block?.type === 'web_search_tool_result') {
                                    console.log('Web search results received:', event.content_block.content?.length, 'results');
                                    // Update the count
                                    const resultCount = event.content_block.content?.length || 0;
                                    const toolCountEl = document.getElementById('tool-' + event.content_block.tool_use_id + '-count');
                                    if (toolCountEl) {
                                        toolCountEl.textContent = `${resultCount} result${resultCount !== 1 ? 's' : ''}`;
                                    }

                                    // Display the results in the content area
                                    const toolContentEl = document.getElementById('tool-' + event.content_block.tool_use_id + '-content');
                                    if (toolContentEl && event.content_block.content) {
                                        const results = event.content_block.content.slice(0, 10); // Show up to 10 results
                                        const resultsHtml = results.map((result, i) =>
                                            `${i + 1}. ${result.title}\n   ${result.url}\n   Age: ${result.page_age || 'Unknown'}`
                                        ).join('\n\n');
                                        toolContentEl.textContent = resultsHtml;
                                    }
                                }
                            }

                            // Handle message_stop to check stop reason
                            if (event.type === 'message_stop') {
                                console.log('Message stopped:', event);
                                stopReason = event.stop_reason || event['amazon-bedrock-invocationMetrics']?.stopReason;
                                console.log('Stop reason:', stopReason);
                            }

                            // Handle message_delta to extract stop_reason
                            if (event.type === 'message_delta') {
                                if (event.delta?.stop_reason) {
                                    stopReason = event.delta.stop_reason;
                                    console.log('Stop reason from delta:', stopReason);
                                }
                            }

                            // Handle content_block_delta events
                            if (event.type === 'content_block_delta') {
                                // Handle thinking content
                                if (event.delta?.type === 'thinking_delta' && event.delta?.thinking) {
                                    console.log('Received thinking:', event.delta.thinking);

                                    // Create thinking box if not already created
                                    if (!thinkingBoxCreated) {
                                        console.log('Creating thinking box');
                                        const thinkingBoxId = 'thinking-content-' + Date.now();
                                        const thinkingBoxHtml = `
                                            <div class="thinking-box">
                                                <div class="thinking-box-header" onclick="toggleThinkingBox(event)">
                                                    <div class="thinking-box-title">
                                                        <span> Extended thinking</span>
                                                    </div>
                                                    <div class="thinking-box-meta">
                                                        <span class="thinking-box-toggle"></span>
                                                    </div>
                                                </div>
                                                <div class="thinking-box-content collapsed" id="${thinkingBoxId}"></div>
                                            </div>
                                        `;
                                        blocksContainer.insertAdjacentHTML('beforeend', thinkingBoxHtml);
                                        thinkingElement = document.getElementById(thinkingBoxId);
                                        thinkingBoxCreated = true;
                                    }

                                    // Add thinking text and update display
                                    thinkingText += event.delta.thinking;
                                    if (!thinkingPendingUpdate && thinkingElement) {
                                        thinkingPendingUpdate = true;
                                        requestAnimationFrame(updateThinkingDisplay);
                                    }
                                    continue;
                                }

                                // Handle tool input (for both web search and memory)
                                if (event.delta?.type === 'input_json_delta' && event.delta?.partial_json) {
                                    console.log('Received input_json_delta:', event.delta.partial_json);
                                    if (!toolInputJson[event.index]) {
                                        toolInputJson[event.index] = '';
                                    }
                                    toolInputJson[event.index] += event.delta.partial_json;

                                    // Try to parse and update UI
                                    try {
                                        const input = JSON.parse(toolInputJson[event.index]);
                                        console.log('Parsed input:', input);

                                        // Update web search query
                                        if (input.query && currentToolUseId) {
                                            const toolBox = document.getElementById('tool-' + currentToolUseId);
                                            if (toolBox) {
                                                const titleSpan = toolBox.querySelector('.thinking-box-title span');
                                                if (titleSpan) {
                                                    titleSpan.textContent = ` ${input.query}`;
                                                    console.log('Updated search query title to:', input.query);
                                                }
                                            }
                                        }

                                        // Store input for memory tools
                                        if (pendingMemoryTools.length > 0 && event.index < pendingMemoryTools.length) {
                                            pendingMemoryTools[event.index].input = input;
                                        }
                                    } catch (e) {
                                        // JSON not complete yet, wait for more chunks
                                    }
                                }

                                // Handle text content
                                if (event.delta?.text) {
                                    fullText += event.delta.text;

                                    // Start smooth update if not already running
                                    if (!pendingUpdate) {
                                        pendingUpdate = true;
                                        requestAnimationFrame(updateDisplay);
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('Error parsing event:', e, data);
                        }
                    }
                }
            }

            // Ensure final text is displayed
            displayText = fullText;
            streamingTextElement.textContent = fullText;

            // Ensure final thinking text is displayed
            if (thinkingElement && thinkingText) {
                thinkingDisplayText = thinkingText;
                thinkingElement.textContent = thinkingText;
            }

            // Handle memory tool execution if stop_reason is tool_use
            if (stopReason === 'tool_use' && pendingMemoryTools.length > 0) {
                console.log('Executing memory tools:', pendingMemoryTools);

                // Build assistant message content with tool_use blocks
                const assistantMessage = {
                    role: 'assistant',
                    content: []
                };

                // Add text content if any
                if (fullText) {
                    assistantMessage.content.push({
                        type: 'text',
                        text: fullText
                    });
                }

                // Add tool_use blocks
                pendingMemoryTools.forEach(tool => {
                    assistantMessage.content.push({
                        type: 'tool_use',
                        id: tool.id,
                        name: 'memory',
                        input: tool.input
                    });
                });

                // Add assistant message to history
                conversationHistory.push(assistantMessage);

                // Execute memory operations and build tool_result messages
                const toolResults = [];
                for (const tool of pendingMemoryTools) {
                    try {
                        console.log('Executing memory operation:', tool.input.command, tool.input);
                        const result = await handleMemoryOperation(tool.input.command, tool.input);
                        console.log('Memory operation result:', result);

                        // Update UI to show success
                        const memoryBox = document.getElementById(`memory-${tool.id}`);
                        if (memoryBox) {
                            const titleSpan = memoryBox.querySelector('.thinking-box-title span');
                            if (titleSpan) {
                                titleSpan.textContent = ` Memory updated: ${tool.input.path || 'operation completed'}`;
                            }
                            const contentEl = document.getElementById(`memory-${tool.id}-content`);
                            if (contentEl) {
                                contentEl.textContent = JSON.stringify(result, null, 2);
                            }
                        }

                        toolResults.push({
                            type: 'tool_result',
                            tool_use_id: tool.id,
                            content: result.content || JSON.stringify(result)
                        });
                    } catch (error) {
                        console.error('Memory operation failed:', error);
                        toolResults.push({
                            type: 'tool_result',
                            tool_use_id: tool.id,
                            is_error: true,
                            content: error.message
                        });
                    }
                }

                // Add tool_result as user message
                conversationHistory.push({
                    role: 'user',
                    content: toolResults
                });

                // Continue conversation with tool results - recursive call
                console.log('Continuing conversation with tool results');
                await callAnthropicAPIStreaming(thinkingWrapper);
                return;
            }

            // Normal completion - add assistant response to conversation history
            conversationHistory.push({
                role: 'assistant',
                content: fullText
            });

            return fullText;
        }

        function toggleThinkingBox(event) {
            const header = event.currentTarget;
            const box = header.closest('.thinking-box');
            const content = box.querySelector('.thinking-box-content');
            const toggle = box.querySelector('.thinking-box-toggle');

            content.classList.toggle('collapsed');
            toggle.textContent = content.classList.contains('collapsed') ? '' : '';
        }

        function scrollToBottom() {
            const chatContent = document.getElementById('chatContent');
            chatContent.scrollTop = chatContent.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function switchTab(event, tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.sidebar-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            // Add active class to selected tab and content
            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');

            // Check scrollable content after tab switch
            setTimeout(checkScrollableContent, 10);
        }

        async function updateSuggestions() {
            const suggestionsContainer = document.getElementById('suggestionsContainer');
            const suggestionsList = suggestionsContainer.querySelector('.suggestions-list');

            // Show shimmer loading states (3 placeholders)
            suggestionsList.innerHTML = `
                <div class="suggestion-shimmer"></div>
                <div class="suggestion-shimmer"></div>
                <div class="suggestion-shimmer"></div>
            `;
            suggestionsContainer.style.display = 'block';

            try {
                const response = await fetch('/api/suggestions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        conversationHistory: conversationHistory,
                        projectContext: projectContext?.contextForAI || ''
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to generate suggestions');
                }

                const data = await response.json();

                // Clear shimmer states
                suggestionsList.innerHTML = '';

                // Add suggestions one by one with delay
                data.suggestions.forEach((suggestion, index) => {
                    setTimeout(() => {
                        const btn = document.createElement('button');
                        btn.className = 'suggestion-btn';
                        btn.onclick = function() { handleSuggestionClick(this); };
                        btn.textContent = suggestion;
                        suggestionsList.appendChild(btn);
                    }, index * 150); // 150ms delay between each
                });

            } catch (error) {
                console.error('Error generating suggestions:', error);
                // Fallback to generic suggestions on error
                suggestionsList.innerHTML = '';
                const fallbackSuggestions = [
                    "Tell me more about that",
                    "What are the next steps?",
                    "Can you elaborate?"
                ];

                fallbackSuggestions.forEach((suggestion, index) => {
                    setTimeout(() => {
                        const btn = document.createElement('button');
                        btn.className = 'suggestion-btn';
                        btn.onclick = function() { handleSuggestionClick(this); };
                        btn.textContent = suggestion;
                        suggestionsList.appendChild(btn);
                    }, index * 150);
                });
            }
        }
    </script>
</body>
</html>
